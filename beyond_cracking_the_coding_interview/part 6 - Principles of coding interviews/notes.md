# Part 6 - Principles of coding interviews

- We'll get to know 80% of the most common topics and ideas used in interview problems
- Learn problem-solving strategies so we can figure out 80% of questions on your own

### The principles and the catalog

#### Principles

- Study plan: how to practice with the book
- Universal rubric: how you're evaluated by interviewers
- Interview checklist: breaking down each step you should take in a coding interview
- Big-O analysis: In-depth coverage of the "language" of technical interviews
- Problem-solving strategies: boundary thinking, trigger thinking, and problem-solving boosters

#### Catalog

DSA

- Tier 1: essential topics, from sets & maps to trees and graphs
- Tier 2: intermediate topics like heaps, sliding windows, and prefix sums
- Tier 3: Nice topics

### Topics, Recipes, and Reusable ideas

- Topic: a chapter from the catalog, like binary search
- Reusable idea: a coding idea that can be typically used across problems (and even topics)
- Coding recipe: pseudo-code template related to a specific topic that can be used as building block to solve similar problems with small tweaks

## Chapter 18 - How to practice

Phase 1: learn the topics from the catalog
Phase 2: Interview simulation

#### Tier 1

Foundational topics that arise often

- Dynamic arrays
- String manipulation
- Two pointers
- Grids & matrices
- Binary search
- Sets & Maps
- Stacks & Queues
- Recursion
- Sorting
- Linked lists
- Trees
- Graphs

#### Tier 2

Common and important, but need some foundation beforehand

- Heaps
- Sliding windows
- Backtracking
- Topological sorting
- Prefix sums
- Dynamic programming
- Greedy algorithms

#### Tier 3

Extra credit

- Monotonic stacks & queues
- Union-find
- Data structure design
- Set & Map implementations
- Tries
- Graphs (advanced)
- Dynamic programming (advanced)
- Bit manipulation
- Math

### Study plan

#### Phase 1: Learn the topics

##### Preliminary steps

- Review Big O analysis
- Skim the remaning principles chapters
  These chapters:
  - How you're evaluated
  - Anatomy of a coding interview
  - Boundary thinking
  - Trigger thinking
  - Problem-solving boosters
    ... are about how you apply the knowledge of the catalog to interviews
    Probably you want to take a deeper dive after learning the basic catelog topics, but skimming them now might be useful

##### Interleaved practice

1. Learn a topic: read chapter + do corresponding problems

- Dedicated practice as you go through the chapter the first time is important

2. Interleaved practice: practice interview problems picked randomly from all the topics you have learned so far

- Instead of going one topic at a time, go with interleaved practice

Use the AI to help picking the problems: https://start.interviewing.io/interview-ai/settings

- Once you have learned 4-5 topics begin with it

##### How to do a practice problem effectively

- Don't fixate on time spent per question: don't worry if you need a full-hour to solve a problem
  - If it's more than that, it's not recommended
- Focus on the idea, not the code
  - Don't get hung up on the little things
- Don't neglect post-mortem
  - Whatever you do, don't skip them!
  - Finishing a question is where the long-term learning starts
    - What could I have done differently?
    - What mistakes do I keep making, and how can I adjust my workflow to address them?
    - Is there anything I should add to my cheat sheet?

#### Phase 1: Interview simulation

- When you've learned a good chunks of topics, it's time to move to phase 2

### Study plan tips

- No cramming: shorter, more frequent sessions

  - 1h daily

- Plan for your worst week
- Plan with your willpower in mind
- Schedule time to practice
- Schedule inputs, not the output: Instead of "learning dynamic programming", think "spend an hour per day learning dynamic programming"
- Declare an endpoint

#### Effective Study tips for practice

- Use active learning
- Deliberate practice
  - Refine weak points
  - Use
    - cheat sheet
    - bug list
    - post-mortem
- Seek challenge over question counts
- Leverage AI wisely
- Suffering is optional
  - stick with one-hour maximum timebox, even for hard problems
- Generate multiple interview solutions
  - instead of finding one solution, can you find many to the same problem?
- Respect time limits
  - If you can't design the algo in 20min and up to 1h in total, check the hint or solution
  - Also do a thorough post-mortem
